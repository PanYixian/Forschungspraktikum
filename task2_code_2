//code modified from "https://github.com/willhooper/superpose/blob/master/src/superimposer.cpp"
//working!!!


#include <iostream>
#include <fstream>
#include <vector>
#include <cmath>
using namespace std;

//Superimposer (for adding CB to glycine)
pair< vector< vector<double> > , vector<double> >
superimposer(vector< vector<double> > coord0, vector< vector<double> > coord1, unsigned int natm);

//Applies translation vector and rotation matrix generated by superimposer
void superimposer_move(vector<double>& x, vector< vector<double> >& mtx, vector<double>& vec);

//Used if matrix of wrong dimensions is used.
vector< vector<double> > transpose(vector< vector<double> > coord0);

//For debugging
void printVec(vector< vector<double> > vec);

void printCoord(vector<vector<double>> coord, int num, string atom_type[]);

void printDis(vector<vector<double>> rel_dis, int num);

double RMSD(vector<vector<double>> A, vector<vector<double>> B, int atom_num);


int main() {
    
        ifstream fin;
        ofstream fout;
        int atom_num_0, atom_num_1;                                      //the number of atoms in the molecule
        int i, j, k;
        cin.precision(8);
        cout.precision(8);
        fin.precision(8);
        fout.precision(8);
        cout << fixed;
        fout << fixed;
        
        
        fin.open("aspirin_1.xyz");                                         //open the 1st xyz file and test whether it work2
        if(fin.fail())
            cout << "File failed to open." << endl;

        fin >> atom_num_0;                                               //read in the number of atoms from the first line
        
    //    string energy[4];                                              //deal with the second line concerning energy
    //    for (int i = 0; i < 4; i++) {
    //        fin >> energy[i];
    //        cout << energy[i] << " ";
    //    }
    //    cout << endl;
        
        vector<vector<double>> coord_0(atom_num_0);                      //define a 2D vector to store the coordinates
        string atom_type_0[atom_num_0];                                  //the type of atoms
        
        for (i = 0; i < atom_num_0; i++)                                 //define 3 coordinates (x,y,z) for each atom
            coord_0[i].resize(3);

        for(i = 0; i < atom_num_0; i++)
        {
            fin  >> atom_type_0[i];                                      //read in the type of each atom
            for (j = 0; j < 3; j++)
            {
                fin >> coord_0[i][j];                                    //read in the coordinates x,y,z for each atom
            }
        }
        fin.close();
        
        
        fin.open("aspirin_3.xyz");                                         //open the 2nd xyz file and test whether it work3
        if(fin.fail())
            cout << "File failed to open." << endl;
            
        fin >> atom_num_1;

        vector<vector<double>> coord_1(atom_num_1);
        string atom_type_1[atom_num_1];
            
        for (i = 0; i < atom_num_1; i++)
            coord_1[i].resize(3);

        for(i = 0; i < atom_num_1; i++){
            fin >> atom_type_1[i];
            for (j = 0; j < 3; j++){
                fin >> coord_1[i][j];
            }
        }
        fin.close();
    
    cout << "The original coordinates from 2nd file:" << endl;
    printCoord(coord_1, atom_num_1, atom_type_1);
    cout << endl;
    
    
    //build two n*n matrix for storing the characteristic relative atom-atom distances
    
    vector<vector<double>> rel_dis_0(atom_num_0), rel_dis_1(atom_num_1);
    
    for (i = 0; i < atom_num_1; i++){
        rel_dis_0[i].resize(atom_num_0);
        rel_dis_1[i].resize(atom_num_1);
    }
    
    //calculate and sort the relative distances for each atom from the 1st file
    
    for (i = 0; i < atom_num_0; i++) {
        for (j = 0; j < atom_num_0; j++) {
            rel_dis_0[i][j] = sqrt(pow(coord_0[i][0] - coord_0[j][0], 2) +
                                   pow(coord_0[i][1] - coord_0[j][1], 2) + pow(coord_0[i][2] - coord_0[j][2], 2));
        }
        for (j = 0; j < atom_num_0 - 1; j++) {
            for (k = j + 1; k < atom_num_0; k++) {
                if (rel_dis_0[i][j] > rel_dis_0[i][k]) {
                    swap(rel_dis_0[i][j], rel_dis_0[i][k]);
                }
            }
        }
    }
    
    //calculate and sort the relative distances for each atom from the 2nd file
    
    for (i = 0; i < atom_num_1; i++) {
        for (j = 0; j < atom_num_1; j++) {
            rel_dis_1[i][j] = sqrt(pow(coord_1[i][0] - coord_1[j][0], 2) +
                                   pow(coord_1[i][1] - coord_1[j][1], 2) + pow(coord_1[i][2] - coord_1[j][2], 2));
        }
        for (j = 0; j < atom_num_1 - 1; j++) {
            for (k = j + 1; k < atom_num_1; k++) {
                if (rel_dis_1[i][j] > rel_dis_1[i][k]) {
                    swap(rel_dis_1[i][j], rel_dis_1[i][k]);
                }
            }
        }
    }
    
    //check the sorted relative distances
    
    cout << "The sorted relative distance for each atom from the 1st input file:" << endl;
    printDis(rel_dis_0, atom_num_0);
    cout << endl;
    
    cout << "The sorted relative distance for each atom from the 2nd input file:" << endl;
    printDis(rel_dis_1, atom_num_1);
    cout << endl;
    
    //compare the relative distances and switch the atom order in 2nd file
    
    for (i = 0; i < atom_num_0; i++) {
        
        double min_dev = 10000;
        double dev_sum = 0;
        
        for (j = i; j < atom_num_0; j++) {
            dev_sum = 0;
            for (k = 0; k < atom_num_0; k++) {
                dev_sum = dev_sum + abs(rel_dis_0[i][k] - rel_dis_1[j][k]);
            }
        
                
//           cout << i << " " << j << " " << dev_sum << " " << min_dev << endl;
            
            if (dev_sum < min_dev) {
                swap(rel_dis_1[i], rel_dis_1[j]);
                swap(coord_1[i], coord_1[j]);
                
                cout << atom_type_1[i] << " " << atom_type_1[j];
                
                string temp = atom_type_1[i];
                atom_type_1[i] = atom_type_1[j];
                atom_type_1[j] = temp;
                
                min_dev = dev_sum;
                
//              printCoord(coord_1, atom_num_1, atom_type_1);
            
//              cout << min_dev << endl;
            }
        }
    }
    
    
    
    cout << "The sorted relative distance for each atom from the 2nd input file after comparing:" << endl;
    printDis(rel_dis_1, atom_num_1);
    cout << endl;
    
    cout << "The coordinates from 1st file:" << endl;
    printCoord(coord_0, atom_num_0, atom_type_0);
    cout << endl;
    
    cout << "The coordinates from 2nd file after comparing:" << endl;
    printCoord(coord_1, atom_num_1, atom_type_1);
    
    double RMSD_before, RMSD_after;
    RMSD_before = RMSD(coord_0, coord_1, atom_num_0);
    cout << RMSD_before << endl;
    
    pair<vector<vector<double>>, vector<double>> val;
    vector<vector<double>> mtx(atom_num_1), coord_2(atom_num_1);
        
//    for (i = 0; i < atom_num_1; i++)
//        mtx.resize(3);
    

    val = superimposer(coord_0, coord_1, atom_num_0);
    mtx = val.first;
    
    coord_2 = transpose(mtx);
    
    printCoord(coord_2, atom_num_1, atom_type_1);
    
//    for(i = 0; i < atom_num_1; i++){
//        for (j = 0; j < 3; j++){
//            cout << mtx[j][i] << " ";
//        }
//        cout << endl;
//    }
    
    RMSD_after = RMSD(coord_0, coord_2, atom_num_0);
    cout << RMSD_after << endl;
    
//    printDis(mtx, atom_num_0);
    
    return 0;
}


//------------------Superimposer------------------//
pair<vector<vector<double>>, vector<double>>
superimposer(vector< vector<double> > coord0, vector< vector<double> > coord1, unsigned int natm){

  typedef vector< vector<double> > matrix;
  typedef pair< vector< vector<double> > , vector<double> > return_val;
  //coord0 is the target (probably the input glycine)
  //coord1 is the prediction (alanine backbone minus CB, superpose onto glycine then apply transformation to CB)
  //natm is the number of atoms

  //Given code takes a matrix with the opposite dimensions used, so tranpose 90deg clockwise if necessary
  if (coord0[0].size() == 3){
    coord0 = transpose(coord0);
    coord1 = transpose(coord1);
  }


  matrix mtx;
  mtx.resize(3, std::vector<double>(3, 0.0) );
  std::vector<double> t(3, 0.0);
  std::vector<double> vec(3, 0.0);
  double tolerance = 0.0001;
  double err = 0.0;

  //Error checking
  unsigned int MAXATOM = 200;
  if (natm > MAXATOM){
    std::cerr << "Error! Increase maxatom" << std::endl;
    throw 0;
  }
  if (natm < 4){
    std::cerr << "Error! Too few atoms (must be 4 or greater)" << std::endl;
    throw 0;
  }
  for (unsigned int i = 0; i < natm; ++i){
    if (std::max(coord0[0][i], coord1[0][i]) > 998){
      std::cerr << "Coordinate error!" << coord0[0][i] << " " << coord1[0][i] << std::endl;
      throw 0;
    }
  }

  //---Center on origin---//
  std::vector<double> x0_center(3, 0.0);
  std::vector<double> x1_center(3, 0.0);
  //For each axis, sum all atom coordinates, divide by natm to get avg d to origin
  for (unsigned int i = 0; i < natm; ++i){
    for (int j = 0; j < 3; ++j){
      x0_center[j] = x0_center[j] + coord0[j][i];
      x1_center[j] = x1_center[j] + coord1[j][i];
    }
  }
  for (int i = 0; i < 3; ++i){
    x0_center[i] = x0_center[i] / double(natm);
    x1_center[i] = x1_center[i] / double(natm);
  }

  //Initialize matrices to hold new centered coordinates
  matrix x0;
  x0.resize(3, std::vector<double>(natm, 0.0));
  matrix x1;
  x1.resize(3, std::vector<double>(natm, 0.0));


  //Subtract avg distance from origin from actual coordinates, fill new matrices
  for (unsigned int i = 0; i < natm; ++i){
    for (int j = 0; j < 3; ++j){
      x0[j][i] = coord0[j][i] - x0_center[j];
      x1[j][i] = coord1[j][i] - x1_center[j];
    }
  }


  //---End Center on origin---//


  matrix aa;
  aa.resize(3, std::vector<double>(3, 0.0) );
  for (unsigned int i = 0; i < natm; ++i){
    for (int j = 0; j < 3; ++j){
      for (int k = 0; k < 3; ++k){
        aa[j][k] = aa[j][k] + (x1[j][i] * x0[k][i]);
      }
    }
  }


  //Initialize rotation matrix
  matrix rotation;
    rotation.resize(3, std::vector<double>(3, 0.0));
  rotation[0][0] = 1.0; rotation[1][1] = 1.0; rotation[2][2] = 1.0;


  //---Iterative rotation scheme---//
  int iteration_count = 0;
  bool do51 = true; //"This is a way to deal with those nasty gotos in the FORTRAN code"
  int iflag;
  int ix;
  int iy;
  int iz;
  double sigma;
  double gamma;
  double sg;
  double bb;
  double cc;

  while (true){
    if (do51){
      iflag = 0;
      ix = 0;
    }

    //If the number of iterations exceeds 1000, give up
    ++iteration_count;
    if (iteration_count > 500){ break; }

    iy = ix + 1;
    if (iy == 3){
      iy = 0;
    }
    iz = 3 - ix - iy;

    //What are sigma and gamma?
    sigma = aa[iz][iy] - aa[iy][iz];
    gamma = aa[iy][iy] + aa[iz][iz];
    sg = sqrt( sigma * sigma + gamma * gamma );


    //If root of (sigma^2 + gamma^2) = 0. this is tripped
    if (sg == 0){
      //"Goto 50 in FORTRAN code"
      //If do51 was true at the beginning of this iteration, this will break loop
      ++ix;
      if (iflag == 0){ break; }
      if (ix < 3){ do51 = false; }
      else{ do51 = true; }
      continue;
    }

    sg = 1.0 / sg;
    if (fabs(sigma) < ( tolerance * fabs(gamma)) ){
      //"Goto 50 in FORTRAN code"
      ++ix;
      if (iflag == 0){ break; }
      if (ix < 3){ do51 = false; }
      else{ do51 = true; }

      continue;
    }


    for (int i = 0; i < 3; ++i){
      bb = (gamma * aa[iy][i]) + (sigma * aa[iz][i]);
      cc = (gamma * aa[iz][i]) - (sigma * aa[iy][i]);
      aa[iy][i] = bb * sg;
      aa[iz][i] = cc * sg;
      bb = gamma * rotation[iy][i] + sigma * rotation[iz][i];
      cc = gamma * rotation[iz][i] - sigma * rotation[iy][i];
      rotation[iy][i] = bb * sg;
      rotation[iz][i] = cc * sg;
    }
    iflag = 1;

    //Goto 50 in FORTRAN
    ++ix;
    if (iflag == 0){ break; }
    if (ix < 3){ do51 = false; }
    else{ do51 = true; }

    continue;


  } //End while loop


  //Change x1 coordinates

  for (unsigned int i = 0; i < natm; ++i){
    for (int j = 0; j < 3; ++j){
      t[j] = 0.0;
      for (int k = 0; k < 3; ++k){
        //Seemingly a rotation
        t[j] = t[j] + (rotation[j][k] * x1[k][i]);
      }
    }
    for (int j = 0; j < 3; ++j){
      x1[j][i] = t[j];
    }
  }


  //Calculate RMSD
  for (unsigned int i = 0; i < natm; ++i){
    for (int j = 0; i < 3; ++i){
      err = err + pow( (x0[j][i] - x1[j][i]) , 2 );
    }
  }
  err = sqrt(err / natm);

  //"un-center" points
  for (unsigned int i = 0; i < natm; ++i){
    for (int j = 0; j < 3; ++j){
      coord1[j][i] = x1[j][i] + x0_center[j];
    }
  }

  //Build output matrices
  for (int i = 0; i < 3; ++i){
    t[i] = x0_center[i];
    for (int j = 0; j < 3; ++j){
      mtx[i][j] = rotation[i][j];
      t[i] = t[i] - rotation[i][j] * x1_center[j];
//        cout << mtx[i][j] << " ";
    }
//      cout << endl;
        vec[i] = t[i];
  }
    



  return_val ret = std::make_pair(x1, vec);
  return ret;
}



void superimposer_move(std::vector<double>& x, std::vector< std::vector<double> >& mtx, std::vector<double>& vec){
  std::vector<double> y(3, 0.0);
  for (int i = 0; i < 3; ++i){
    for (int j = 0; j < 3; ++j){
      y[i] = y[i] + (x[j] * mtx[i][j]);
    }
  }
  for (int i = 0; i < 3; ++i){
    y[i] = y[i] + vec[i];
  }

  x = y;
  return;
}


std::vector< std::vector<double> > transpose(std::vector< std::vector<double> > coord0){
  std::vector< std::vector<double> > tmp;
  for (unsigned int i = 0; i < coord0[0].size(); ++i){
    std::vector<double> xyz;
    for (unsigned int j = 0; j < coord0.size(); ++j){
      xyz.push_back(coord0[j][i]);
    }
    tmp.push_back(xyz);
    xyz.clear();
  }
  return tmp;
}


//Matrix output for debugging
void printVec(std::vector< std::vector<double> > vec){
  for (unsigned int i = 0; i < vec.size(); ++i){
    for (unsigned int j = 0; j < (vec[i]).size(); ++j){
      std::cout << vec[i][j] << " ";
    }
    std::cout << std::endl;
  }
}


double RMSD(vector<vector<double>> A, vector<vector<double>> B, int atom_num){
    int i, j;
    double RMSD = 0;
    
    for (i = 0; i < atom_num; i++) {
        for (j = 0; j < 3; j++) {
            RMSD = RMSD + pow((A[i][j] - B[i][j]), 2);
        }
    }
    RMSD = sqrt(RMSD / atom_num);
    
    return RMSD;
}

void printCoord(vector<vector<double>> coord, int num, string atom_type[]){
    for(int i = 0; i < num; i++)
    {
        cout << atom_type[i] << "\t";
        for (int j = 0; j < 3; j++)
        {
            cout << coord[i][j] << "\t";
        }
        cout << endl;
    }
}

void printDis(vector<vector<double>> rel_dis, int num){
    for(int i = 0; i < num; i++)
    {
        for (int j = 0; j < num; j++)
        {
            cout << rel_dis[i][j] << " ";
        }
        cout << endl;
    }
}
