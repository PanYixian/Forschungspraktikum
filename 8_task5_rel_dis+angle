#include <iostream>
#include <fstream>
#include <vector>
#include <Eigen/Geometry>
using namespace std;
using namespace Eigen;


const int column_rel_dis = 100, neighbor = 10;


int main(){
    
    // step1: read in the coordinates
    
    ifstream fin;
    ofstream fout;
    int atom_num_0, atom_num_1;
    int i,j,k;
    cin.precision(8);
    cout.precision(8);
    fin.precision(8);
    fout.precision(8);
    cout << fixed;
    fout << fixed;
    
    fin.open("aspirin_1.xyz");
    if (fin.fail())
        cout << "File failed to open." << endl;
    
    fin >> atom_num_0;
    Matrix3Xd coord_0(3, atom_num_0);
    string atom_type_0[500];
    
    // coordinate stored in column, 3*d matrix
    // read in the reference coordinate coord_0
    
    for (i = 0; i < atom_num_0; i++) {
        fin >> atom_type_0[i];
        for (j = 0; j < 3; j++) {
            fin >> coord_0(j, i);
            }
    }
    fin.close();
    
    fin.open("aspirin_5.xyz");
    if (fin.fail())
        cout << "File failed to open." << endl;
    
    fin >> atom_num_1;
    Matrix3Xd coord_1(3, atom_num_1);
    string atom_type_1[atom_num_1];
    
    // read in the working coordinate coord_1
    
    for (i = 0; i < atom_num_1; i++) {
        fin >> atom_type_1[i];
        for (j = 0; j < 3; j++) {
            fin >> coord_1(j, i);
        }
    }
    fin.close();
    
    // augment the array of element type of reference to the size of working and fill with "None"
    // currently not remember why....
    
    for (i = atom_num_0; i < atom_num_1; i++) {
        atom_type_0[i] = "None";
    }
    
    
    // step2: calculate the centroids and translate both coordinate sets to origin
        
    Vector3d centroid_0 = Vector3d::Zero(), centroid_1 = Vector3d::Zero();
    
    for (i = 0; i < 3; i++) {
        double sum_0 = 0;
        for (j = 0; j < atom_num_0; j++) {
            sum_0 = sum_0 + coord_0(i, j);
        }
        centroid_0(i) = sum_0 / atom_num_0;
    }
        
    for (i = 0; i < 3; i++) {
        double sum_1 = 0;
        for (j = 0; j < atom_num_1; j++) {
            sum_1 = sum_1 + coord_1(i, j);
        }
        centroid_1(i) = sum_1 / atom_num_1;
    }
        
//    cout << "centroid of 1st file: " << endl << centroid_0 << endl;
//    cout << "centroid of 2nd file: " << endl << centroid_1 << endl;
//    cout << endl;
        
    for (i = 0; i < 3; i++) {
        for (j = 0; j < atom_num_0; j++) {
            coord_0(i, j) -= centroid_0(i);
        }
        for (j = 0; j < atom_num_1; j++) {
            coord_1(i, j) -= centroid_1(i);
        }
    }
    
    
    // step3: construct rel_dis matrix with distance and angular information
    // angular information from the nearest 10 neighbors of each atom
    
    
    MatrixXd rel_dis_0 = MatrixXd::Zero(2 * atom_num_1, column_rel_dis), rel_dis_1 = MatrixXd::Zero(2 * atom_num_1, column_rel_dis);
    vector<int> position(atom_num_1);
    
    for (i = 0; i < atom_num_0; i++) {
        
    // calculate the atom-atom distances for i-th atom, store the position of neighbors in position[j]
        
        for (j = 0; j < atom_num_0; j++) {
            rel_dis_0(i,j) = sqrt(pow((coord_0(0,i)-coord_0(0,j)), 2) +
                                  pow((coord_0(1,i)-coord_0(1,j)), 2) +
                                  pow((coord_0(2,i)-coord_0(2,j)), 2));
            position[j] = j;
        }
        
    // sort it
        
        for (j = 0; j < atom_num_0-1; j++) {
            for (k = j+1; k < atom_num_0; k++) {
                if (rel_dis_0(i,j) > rel_dis_0(i,k)){
                    swap(rel_dis_0(i,j), rel_dis_0(i,k));
                    swap(position[j], position[k]);
                }
            }
        }
        
//        for (j = 0; j < atom_num_0; j++) cout << position[j] << " ";
//        cout << endl;
    
    // calculate the angular information for i-th atom with 10 nearest neighbors
        
        int count = 0;
        for (j = 1; j < neighbor; j++) {
            for (k = j+1; k < neighbor+1; k++) {
                rel_dis_0(atom_num_1 + i, count) = (((coord_0(0, position[j]) - coord_0(0,i)) * (coord_0(0, position[k]) - coord_0(0,i)))
                                                  + ((coord_0(1, position[j]) - coord_0(1,i)) * (coord_0(1, position[k]) - coord_0(1,i)))
                                                  + ((coord_0(2, position[j]) - coord_0(2,i)) * (coord_0(2, position[k]) - coord_0(2,i))))
                                                 / (rel_dis_0(i, position[j]) * rel_dis_0(i, position[k]));
                
                // cout << rel_dis_0(i, position[j]) << " " << rel_dis_0(i, position[k]) << " " << rel_dis_0(atom_num_1 + i, count) << " ";
                
                count++;
            }
        }
    
    // sort the angular information
        
        for (j = 0; j < 44; j++) {
            for (k = j+1; k < 45; k++) {
                if (rel_dis_0(atom_num_1 + i, j) > rel_dis_0(atom_num_1 + i, k))
                    swap(rel_dis_0(atom_num_1 + i, j), rel_dis_0(atom_num_1 + i, k));
            }
        }
        
    }
    
    cout << rel_dis_0 << endl;
    
    for (i = 0; i < atom_num_0; i++) {
        cout << position[i] << " ";
    }
    
    
    return 0;
}
